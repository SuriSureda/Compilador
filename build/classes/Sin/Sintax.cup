package compilador;


import java_cup.runtime.Symbol;      // CLASE SYMBOL PARA LOS TOKENS



parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
    this.s = s;
    }

    public Symbol getS(){
    return this.s;
    }
:};

/******Declaració de simbols terminals*********/
terminal        character, id, number, string, bool, Void, op_relational, op_logical, op_arithmetical, op_assig, inst_if, inst_elif, inst_else,
                inst_switch, inst_case, inst_break, inst_default, inst_while, inst_for, inst_function, inst_return, dconst, inst_call, 
                instr_in, instr_out,  lparen, rparen, lbracket, rbracket, nextinstr, separator, two_points, inst_main,id_main,
                spc_asgmul, spc_asgdec, spc_dec,spc_asgdiv,spc_asginc,spc_inc ;


/******Declaració de simbols no terminals*********/

non terminal STARTS, INSTRUCTIONS, INSTRUCTION, DECLARATIONS, OPERATOR_ASSIG, INSTRUCTION_IN, INSTRUCTION_OUT, CONSTANT,VALUE,
               INITIALIZE_ARITHMETICAL_OP, ARITHMETICAL_OP, ARITHMETICAL_VALUE, POS_NEG, BOOLEAN_OP, INITIALIZE_BOOLEAN_OP, BOOLEAN_VALUE, VALUE_COMPARISON,
             INSTRUCTION_IF, OTHER_CASES, INSTRUCTION_WHILE, INSTRUCTION_FOR, INTERNAL_FOR, INSTRUCTION_SWITCH, CASES, CASE_DEFAULT, DEFINE_FUNCTION,
             CALL_FUNCTION, CALL_BODY, FUNCTION_BEG,PARAMETERS, HAS_PARAMETERS,HAS_MORE_PARAMETERS, FUNCTION_BODY, RETURN_TYPE, CALL_MAIN, INIT;


start with STARTS;

STARTS                      ::=  INIT DEFINE_FUNCTION CALL_MAIN ;

INIT                        ::= ;

DEFINE_FUNCTION             ::= lparen; // TOCARÁ CAMBIARSE EN UN FUTURO SEMANTICO

CALL_MAIN                   ::= inst_main lparen id_main rparen nextinstr;

INSTRUCTIONS                ::=   INSTRUCTIONS INSTRUCTION
                            | INSTRUCTION ;

INSTRUCTION                 ::=  DECLARATIONS
                            | INSTRUCTION_IF
                            | INSTRUCTION_WHILE
                            | INSTRUCTION_SWITCH
                            | INSTRUCTION_FOR
                            | OPERATOR_ASSIG
                            | INSTRUCTION_IN
                            | INSTRUCTION_OUT 
                            | DEFINE_FUNCTION;



DECLARATIONS                ::=  id separator DECLARATIONS
                            | id CONSTANT two_points id op_assig VALUE nextinstr 
                            | spc_asgmul
                            | spc_asgdec    
                            | spc_dec
                            | spc_asgdiv
                            | spc_asginc
                            | spc_inc;


CONSTANT                    ::=  dconst
                            |  ;


OPERATOR_ASSIG              ::= id op_assig VALUE nextinstr;    


INITIALIZE_ARITHMETICAL_OP  ::= lparen ARITHMETICAL_OP rparen ;


ARITHMETICAL_OP             ::= ARITHMETICAL_OP op_arithmetical ARITHMETICAL_VALUE
                            | ARITHMETICAL_VALUE op_arithmetical ARITHMETICAL_VALUE ;

 
ARITHMETICAL_VALUE          ::= lparen ARITHMETICAL_OP rparen
                            | POS_NEG number
                            | id ;


POS_NEG                     ::= op_arithmetical    /*  + 25  */
                            |  ;


VALUE                       ::= INITIALIZE_ARITHMETICAL_OP
                            | POS_NEG number
                            | character
                            | string
                            | bool
                            | id
                            | INITIALIZE_BOOLEAN_OP
                            | CALL_FUNCTION
                            | Void
                            | instr_in lparen id rparen;

INITIALIZE_BOOLEAN_OP       ::= lparen BOOLEAN_OP rparen ;

BOOLEAN_OP                  ::= BOOLEAN_OP op_logical BOOLEAN_VALUE
                            | BOOLEAN_VALUE ;

BOOLEAN_VALUE               ::= bool
                            | id
                            | lparen BOOLEAN_OP rparen
                            | VALUE_COMPARISON ;

VALUE_COMPARISON            ::= lparen VALUE op_relational VALUE rparen ;



INSTRUCTION_IF               ::= inst_if lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES; // if(( x < y)){}

OTHER_CASES                  ::= inst_else lbracket INSTRUCTIONS rbracket  // else{}
                             | inst_elif lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES // elif ((x > y)){}
                             | ;

 
INSTRUCTION_WHILE            ::= inst_while lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket;         // while(( x < 10)){}


INSTRUCTION_FOR              ::= inst_for lparen INTERNAL_FOR rparen lbracket INSTRUCTIONS rbracket;
INTERNAL_FOR                 ::= OPERATOR_ASSIG nextinstr INITIALIZE_BOOLEAN_OP nextinstr ARITHMETICAL_OP 
                             | ;


INSTRUCTION_SWITCH           ::= inst_switch lparen VALUE rparen lbracket CASES rbracket ;
CASES                        ::= inst_case VALUE two_points INSTRUCTIONS inst_break nextinstr CASES
                             | CASE_DEFAULT;
CASE_DEFAULT                 ::= inst_default INSTRUCTIONS inst_break nextinstr
                             | ;


CALL_FUNCTION               ::= inst_call lparen CALL_BODY rparen nextinstr;

CALL_BODY                   ::= CALL_BODY separator VALUE
                            | id;


INSTRUCTION_OUT             ::= instr_out lparen VALUE rparen nextinstr;





DEFINE_FUNCTION             ::= FUNCTION_BEG id  rparen lbracket FUNCTION_BODY RETURN_TYPE  rbracket;

FUNCTION_BEG                ::= inst_function id id lparen PARAMETERS rparen;

PARAMETERS                  ::= HAS_PARAMETERS
                            | ;

HAS_PARAMETERS              ::=  id id HAS_MORE_PARAMETERS ;

HAS_MORE_PARAMETERS         ::= separator id id HAS_MORE_PARAMETERS
                            | ;

FUNCTION_BODY               ::= INSTRUCTIONS
                            | ;

RETURN_TYPE                 ::= inst_return VALUE nextinstr
                            | ;

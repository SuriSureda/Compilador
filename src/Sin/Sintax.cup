package compilador;


import java_cup.runtime.Symbol;
import Symbols.*;
import SymbolsTable.*;

class Parser;

parser code
{:
  private SymbolsTable symbolsTable;
  private LexerCup scanner;

  public Parser(LexerCup scanner){
    super(scanner)
    this.symbolsTable = new SymbolsTable();
  }

  public void syntax_error(Symbol current_token) {
      report_error(
          "Syntax error at line " + (current_token.left+1) + ", column "
          + current_token.right, null
      );
  }

:};

/******Declaració de simbols terminals*********/
terminal        character, id, number, string, bool, Void, op_relational, op_logical, op_arithmetical, op_assig, inst_if, inst_elif, inst_else,
                inst_switch, inst_case, inst_break, inst_default, inst_while, inst_for, inst_function, inst_return, dconst, inst_call, 
                instr_in, instr_out,  lparen, rparen, lbracket, rbracket, nextinstr, separator, two_points, inst_main,id_main,
                spc_asgmul, spc_asgdec, spc_dec,spc_asgdiv,spc_asginc,spc_inc ;


/******Declaració de simbols no terminals*********/

non terminal  SymbolStarts                STARTS;
non terminal  SymbolInit                  INIT;
non terminal  SymbolCallMain              CALL_MAIN;
non terminal  SymbolInstructions          INSTRUCTIONS;
non terminal  SymbolInstruction           INSTRUCTION;
non terminal  SymbolDeclarations          DECLARATIONS;
non terminal  SymbolOperatorAssignation   OPERATOR_ASSIG;
non terminal  SymbolInstructionIn         INSTRUCTION_IN;
non terminal  SymbolInstructionOut        INSTRUCTION_OUT;
non terminal  SymbolConstant              CONSTANT;
non terminal  SymbolValue                 VALUE;
non terminal  SymbolInitArithOp           INITIALIZE_ARITHMETICAL_OP;
non terminal  SymbolArithmeticalOperator  ARITHMETICAL_OP;
non terminal  SymbolArithValue            ARITHMETICAL_VALUE;
non terminal  SymbolPosNeg                POS_NEG;
non terminal  SymbolBoolOp                BOOLEAN_OP;
non terminal  SymbolInitBoolOp            INITIALIZE_BOOLEAN_OP;
non terminal  SymbolBoolValue             BOOLEAN_VALUE;
non terminal  SymbolValueComparison       VALUE_COMPARISON;
non terminal  SymbolInstructionIf         INSTRUCTION_IF;
non terminal  SymbolOtherCases            OTHER_CASES;
non terminal  SymbolInstructionWhile      INSTRUCTION_WHILE;
non terminal  SymbolInstructionFor        INSTRUCTION_FOR;
non terminal  SymbolInternalFor           INTERNAL_FOR;
non terminal  SymbolInstructionSwitch     INSTRUCTION_SWITCH;
non terminal  SymbolCases                 CASES;
non terminal  SymbolCaseDefault           CASE_DEFAULT;
non terminal  SymbolDefFunction           DEFINE_FUNCTION;
non terminal  SymbolCallFunction          CALL_FUNCTION;
non terminal  SymbolCallBody              CALL_BODY;
non terminal  SymbolFunctionBeg           FUNCTION_BEG;
non terminal  SymbolParameters            PARAMETERS;
non terminal  SymbolHasParameters         HAS_PARAMETERS;
non terminal  SymbolHasMoreParameters     HAS_MORE_PARAMETERS;
non terminal  SymbolFunctionBody          FNCTION_BODY;
non terminal  SymbolReturnType            RETURN_TYPE;

start with STARTS;

STARTS                      ::=  INIT CALL_MAIN;

INIT                        ::= {:
                              initTypes();
                              RESULT = new SymbolInit();
                            :};

CALL_MAIN                   ::= inst_main lparen id:id_main rparen nextinstr {:
                              Type type = symbolsTable.get(id_main);
                              
                              RESULT = new SymbolCallMain();
                            :};

INSTRUCTIONS                ::=   INSTRUCTIONS INSTRUCTION 
                            {:
                              RESULT = new SymbolInstructions();
                            :};
                            | INSTRUCTION 
                            {:
                              RESULT = new SymbolInstructions();
                            :};

INSTRUCTION                 ::=  DECLARATIONS 
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_IF 
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_WHILE
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_SWITCH
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_FOR
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | OPERATOR_ASSIG
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_IN
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_OUT 
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | DEFINE_FUNCTION;
                            {:
                              RESULT = new SymbolInstruction();
                            :};

DECLARATIONS                ::=  id:var_id separator DECLARATIONS:declarations
                            {:
                              Type type = declarations.getType();
                              //COSES DE BACKEND

                              symbolsTable.add(var_id, type);

                              RESULT = new SymbolInstruction();
                            :}
                            | id:id_var CONSTANT:const two_points id:type_id op_assig VALUE:value nextinstr  
                            {:
                              boolean isConst = const.getIsConst();
                              
                              Type typeDes = symbolsTable.get(type_id);
                              if(typeDes.getType() != TYPE.dtype){
                                throw Error("Type not valid")
                              }

                              if(typeDes.getSubType() != SUBJACENTTYPE.st_boolean
                                && typeDes.getSubType() != SUBJACENTTYPE.st_boolean
                                && typeDes.getSubType() != SUBJACENTTYPE.st_boolean ){
                                  throw Error("Invalid subjacent type")
                              }

                              //IF LITERALL (type = null) CHECK SUBJACENT TYPE
                              if(value.getType() == TYPE.dnull && typeDes.getSubType() == value.getSubType()){
                                throw Error("Value and type must have same subjacent type")
                              }
                              
                              if(value.getType() != TYPE.dnull && value.getNameType() != type_id){
                                throw Error("Value must have the same type")
                              }
                              Type varType;

                              if(isConst){
                                varType = new Type(TYPE.dconst, type_id, value.getValue());
                              }
                              else{
                                varType = new Type(TYPE.dvar, type_id);
                              }

                              //COSES BACKEND
                               
                              symbolsTable.put(id_var, varType);
                              SymbolDeclarations symDcls = new SymbolDeclarations(varType)

                              RESULT = symDcls;
                            :}
                            | spc_asgmul
                            | spc_asgdec    
                            | spc_dec
                            | spc_asgdiv
                            | spc_asginc
                            | spc_inc;


CONSTANT                    ::=  dconst  
                            {:
                              RESULT = new SymbolConstant(true);
                            :}
                            |  
                            {:
                              RESULT = new SymbolConstant(false);
                            :};


OPERATOR_ASSIG              ::= id op_assig VALUE nextinstr;    


INITIALIZE_ARITHMETICAL_OP  ::= lparen ARITHMETICAL_OP rparen ;


ARITHMETICAL_OP             ::= ARITHMETICAL_OP op_arithmetical ARITHMETICAL_VALUE
                            | ARITHMETICAL_VALUE op_arithmetical ARITHMETICAL_VALUE ;

 
ARITHMETICAL_VALUE          ::= lparen ARITHMETICAL_OP rparen
                            | POS_NEG number
                            | id ;


POS_NEG                     ::= op_arithmetical    /*  + 25  */
                            |  ;


VALUE                       ::= INITIALIZE_ARITHMETICAL_OP
                            | POS_NEG number
                            | character
                            | string
                            | bool
                            | id
                            | INITIALIZE_BOOLEAN_OP
                            | CALL_FUNCTION
                            | Void
                            | instr_in lparen id rparen;

INITIALIZE_BOOLEAN_OP       ::= lparen BOOLEAN_OP rparen ;

BOOLEAN_OP                  ::= BOOLEAN_OP op_logical BOOLEAN_VALUE
                            | BOOLEAN_VALUE ;

BOOLEAN_VALUE               ::= bool
                            | id
                            | lparen BOOLEAN_OP rparen
                            | VALUE_COMPARISON ;

VALUE_COMPARISON            ::= lparen VALUE op_relational VALUE rparen ;



INSTRUCTION_IF               ::= inst_if lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES; // if(( x < y)){}

OTHER_CASES                  ::= inst_else lbracket INSTRUCTIONS rbracket  // else{}
                             | inst_elif lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES // elif ((x > y)){}
                             | ;

 
INSTRUCTION_WHILE            ::= inst_while lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket;         // while(( x < 10)){}


INSTRUCTION_FOR              ::= inst_for lparen INTERNAL_FOR rparen lbracket INSTRUCTIONS rbracket;
INTERNAL_FOR                 ::= OPERATOR_ASSIG nextinstr INITIALIZE_BOOLEAN_OP nextinstr ARITHMETICAL_OP 
                             | ;


INSTRUCTION_SWITCH           ::= inst_switch lparen VALUE rparen lbracket CASES rbracket ;
CASES                        ::= inst_case VALUE two_points INSTRUCTIONS inst_break nextinstr CASES
                             | CASE_DEFAULT;
CASE_DEFAULT                 ::= inst_default INSTRUCTIONS inst_break nextinstr
                             | ;


CALL_FUNCTION               ::= inst_call lparen CALL_BODY rparen nextinstr;

CALL_BODY                   ::= CALL_BODY separator VALUE
                            | id;


INSTRUCTION_OUT             ::= instr_out lparen VALUE rparen nextinstr;


DEFINE_FUNCTION             ::= FUNCTION_BEG id  rparen lbracket FUNCTION_BODY RETURN_TYPE  rbracket;

FUNCTION_BEG                ::= inst_function id id lparen PARAMETERS rparen;

PARAMETERS                  ::= HAS_PARAMETERS
                            | ;

HAS_PARAMETERS              ::=  id id HAS_MORE_PARAMETERS ;

HAS_MORE_PARAMETERS         ::= separator id id HAS_MORE_PARAMETERS
                            | ;

FUNCTION_BODY               ::= INSTRUCTIONS
                            | ;

RETURN_TYPE                 ::= inst_return VALUE nextinstr
                            | ;

package compilador;


import java_cup.runtime.Symbol;
import Symbols.*;
import SymbolsTable.*;
import backend.Instruction; //For op Code

class Parser;

parser code
{:
  private SymbolsTable symbolsTable;
  private LexerCup scanner;

  public Parser(LexerCup scanner){
    super(scanner)
    this.symbolsTable = new SymbolsTable();
  }

  public void syntax_error(Symbol current_token) {
      report_error(
          "Syntax error at line " + (current_token.left+1) + ", column "
          + current_token.right, null
      );
  }

:};

/******Declaració de simbols terminals*********/
terminal        character, id, number, string, bool, Void, op_relational, op_logical, op_arithmetical, op_assig, inst_if, inst_elif, inst_else,
                inst_switch, inst_case, inst_break, inst_default, inst_while, inst_for, inst_function, inst_return, dconst, inst_call, 
                instr_in, instr_out,  lparen, rparen, lbracket, rbracket, nextinstr, separator, two_points, inst_main,id_main,
                spc_asgmul, spc_asgdec, spc_dec,spc_asgdiv,spc_asginc,spc_inc ;


/******Declaració de simbols no terminals*********/

non terminal  SymbolStarts                STARTS;
non terminal  SymbolInit                  INIT;
non terminal  SymbolCallMain              CALL_MAIN;
non terminal  SymbolInstructions          INSTRUCTIONS;
non terminal  SymbolInstruction           INSTRUCTION;
non terminal  SymbolDeclarations          DECLARATIONS;
non terminal  SymbolOperatorAssignation   OPERATOR_ASSIG;
non terminal  SymbolInstructionIn         INSTRUCTION_IN;
non terminal  SymbolInstructionOut        INSTRUCTION_OUT;
non terminal  SymbolConstant              CONSTANT;
non terminal  SymbolValue                 VALUE;
non terminal  SymbolInitArithOp           INITIALIZE_ARITHMETICAL_OP;
non terminal  SymbolArithmeticalOperator  ARITHMETICAL_OP;
non terminal  SymbolArithValue            ARITHMETICAL_VALUE;
non terminal  SymbolPosNeg                POS_NEG;
non terminal  SymbolBoolOp                BOOLEAN_OP;
non terminal  SymbolInitBoolOp            INITIALIZE_BOOLEAN_OP;
non terminal  SymbolBoolValue             BOOLEAN_VALUE;
non terminal  SymbolValueComparison       VALUE_COMPARISON;
non terminal  SymbolInstructionIf         INSTRUCTION_IF;
non terminal  SymbolOtherCases            OTHER_CASES;
non terminal  SymbolInstructionWhile      INSTRUCTION_WHILE;
non terminal  SymbolInstructionFor        INSTRUCTION_FOR;
non terminal  SymbolInternalFor           INTERNAL_FOR;
non terminal  SymbolInstructionSwitch     INSTRUCTION_SWITCH;
non terminal  SymbolCases                 CASES;
non terminal  SymbolCaseDefault           CASE_DEFAULT;
non terminal  SymbolDefFunction           DEFINE_FUNCTION;
non terminal  SymbolCallFunction          CALL_FUNCTION;
non terminal  SymbolCallBody              CALL_BODY;
non terminal  SymbolFunctionBeg           FUNCTION_BEG;
non terminal  SymbolParameters            PARAMETERS;
non terminal  SymbolHasParameters         HAS_PARAMETERS;
non terminal  SymbolHasMoreParameters     HAS_MORE_PARAMETERS;
non terminal  SymbolFunctionBody          FNCTION_BODY;
non terminal  SymbolReturnType            RETURN_TYPE;

start with STARTS;

STARTS                      ::=  INIT CALL_MAIN;

INIT                        ::= {:
                              initTypes();
                              RESULT = new SymbolInit();
                            :};

CALL_MAIN                   ::= inst_main lparen id:id_main rparen nextinstr {:
                              Type type = symbolsTable.get(id_main);
                              
                              RESULT = new SymbolCallMain();
                            :};

INSTRUCTIONS                ::=   INSTRUCTIONS INSTRUCTION 
                            {:
                              RESULT = new SymbolInstructions();
                            :};
                            | INSTRUCTION 
                            {:
                              RESULT = new SymbolInstructions();
                            :};

INSTRUCTION                 ::=  DECLARATIONS 
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_IF 
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_WHILE
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_SWITCH
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_FOR
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | OPERATOR_ASSIG
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_IN
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | INSTRUCTION_OUT 
                            {:
                              RESULT = new SymbolInstruction();
                            :}
                            | DEFINE_FUNCTION;
                            {:
                              RESULT = new SymbolInstruction();
                            :};

DECLARATIONS                ::=  id:var_id separator DECLARATIONS:declarations
                            {:
                              Type type = declarations.getType();
                              //COSES DE BACKEND

                              symbolsTable.add(var_id, type);

                              RESULT = new SymbolInstruction();
                            :}
                            | id:id_var CONSTANT:const two_points id:type_id op_assig VALUE:value nextinstr  
                            {:
                              boolean isConst = const.getIsConst();
                              
                              Type typeDes = symbolsTable.get(type_id);
                              if(typeDes.getType() != TYPE.dtype){
                                throw new Error("Type not valid")
                              }

                              if(typeDes.getSubType() != SUBJACENTTYPE.st_boolean
                                && typeDes.getSubType() != SUBJACENTTYPE.st_boolean
                                && typeDes.getSubType() != SUBJACENTTYPE.st_boolean ){
                                  throw new Error("Invalid subjacent type")
                              }

                              //IF LITERALL (type = null) CHECK SUBJACENT TYPE
                              if(value.getType() == TYPE.dnull && typeDes.getSubType() == value.getSubType()){
                                throw new Error("Value and type must have same subjacent type")
                              }
                              
                              if(value.getType() != TYPE.dnull && value.getNameType() != type_id){
                                throw new Error("Value must have the same type")
                              }
                              Type varType;

                              if(isConst){
                                varType = new Type(TYPE.dconst, type_id, value.getValue());
                              }
                              else{
                                varType = new Type(TYPE.dvar, type_id);
                              }

                              //COSES BACKEND
                               
                              symbolsTable.put(id_var, varType);
                              SymbolDeclarations symDcls = new SymbolDeclarations(varType)

                              RESULT = symDcls;
                            :};


CONSTANT                    ::=  dconst  
                            {:
                              RESULT = new SymbolConstant(true);
                            :}
                            |  
                            {:
                              RESULT = new SymbolConstant(false);
                            :};


OPERATOR_ASSIG              ::= id:var_id op_assig VALUE:value nextinstr 
                            {:
                              Type varType = symbolsTable.get(id_var);
                              if(varType.getType() == TYPE.dconst){
                                throw new Error("Cant assign value to constant")
                              }

                              //IF LITERALL (type = null) CHECK SUBJACENT TYPE
                              if(value.getType() == TYPE.dnull && typeDes.getSubType() == value.getSubType()){
                                throw new Error("Value and type must have same subjacent type")
                              }
                              
                              if(value.getType() != TYPE.dnull && value.getNameType() != type_id){
                                throw new Error("Value must have the same type")
                              }

                              //COSES BACKEND

                              RESULT = new SymbolOperatorAssignation();
                            :};    


INITIALIZE_ARITHMETICAL_OP  ::= lparen ARITHMETICAL_OP:arith_op rparen 
                            {:
                              SymbolInitArithOp sym; 
                              if(arith_op.getIsConst()){
                                sym = new SymbolInitArithOp(arith_op.getVarId(),arith_op.getValue());
                              }else{
                                sym = new SymbolInitArithOp(arith_op.getVarId());
                              }

                              RESULT = sym;
                            :};


ARITHMETICAL_OP             ::= ARITHMETICAL_OP:arith_op op_arithmetical:op ARITHMETICAL_VALUE:arith_val
                            {:
                              
                              SymbolArithmeticalOperator sym;
                              boolean allConst = arith_op.getIsConst() && arith_val.getIsConst();

                              Code op_code;
                              switch(op){
                                case "+" : 
                                  op_code = Code.add;
                                  break;
                                case "-" : 
                                  op_code = Code.sub;
                                  break;
                                case "*" : 
                                  op_code = Code.prod;
                                  break;
                                case "/" : 
                                  op_code = Code.div;
                                  break;
                                case "%" : 
                                  op_code = Code.mod;
                                  break;
                                default : 
                                  throw new Error("Invalid arithmetical operator");
                              }

                              Integer value;
                              if(allConst) {
                                Integer val1 = (Integer) aright_op.getValue();
                                Integer val2 = (Integer) arith_val.getValue();

                                switch(op){
                                  case "+" : 
                                    value = val1 + val2;
                                    break;
                                  case "-" : 
                                    value = val1 - val2;
                                    break;
                                  case "*" : 
                                    value = val1 * val2;
                                    break;
                                  case "/" : 
                                    if(val2 == 0){
                                      throw new Error("Cannot divide by zero");
                                    }
                                    value = val1 / val2;
                                    break;
                                  case "%" : 
                                    value = val1 % val2;
                                    break;
                                }
                              }

                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND
                              if(allConst){
                                sym = new SymbolArithmeticalOperator(var_id, value)
                              }
                              else{
                                sym = new SymbolArithmeticalOperator(var_id)
                              }

                              RESULT = sym;

                            :};
                            | ARITHMETICAL_VALUE:arith_val1 op_arithmetical:op ARITHMETICAL_VALUE:arith_val2
                              SymbolArithmeticalOperator sym;
                              boolean allConst = arith_val1.getIsConst() && arith_val2.getIsConst();

                              Code op_code;
                              switch(op){
                                case "+" : 
                                  op_code = Code.add;
                                  break;
                                case "-" : 
                                  op_code = Code.sub;
                                  break;
                                case "*" : 
                                  op_code = Code.prod;
                                  break;
                                case "/" : 
                                  op_code = Code.div;
                                  break;
                                case "%" : 
                                  op_code = Code.mod;
                                  break;
                                default : 
                                  throw new Error("Invalid arithmetical operator");
                              }

                              Integer value;
                              if(allConst) {
                                Integer val1 = (Integer) arith_val1.getValue();
                                Integer val2 = (Integer) arith_val2.getValue();

                                switch(op){
                                  case "+" : 
                                    value = val1 + val2;
                                    break;
                                  case "-" : 
                                    value = val1 - val2;
                                    break;
                                  case "*" : 
                                    value = val1 * val2;
                                    break;
                                  case "/" : 
                                    if(val2 == 0){
                                      throw new Error("Cannot divide by zero");
                                    }
                                    value = val1 / val2;
                                    break;
                                  case "%" : 
                                    value = val1 % val2;
                                    break;
                                }
                              }

                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND
                              if(allConst){
                                sym = new SymbolArithmeticalOperator(var_id, value);
                              }
                              else{
                                sym = new SymbolArithmeticalOperator(var_id);
                              }
                              
                              RESULT = sym;
                            {:

                            :};

 
ARITHMETICAL_VALUE          ::= lparen ARITHMETICAL_OP:arith_op rparen
                            {:
                              SymbolArithValue sym;
                              String var_id = new String(arith_op.getVarId());

                              if(arith_op.getIsConst()){
                                sym = new SymbolArithmeticalValue(var_id, arith_op.getValue());
                              }else{
                                sym = new SymbolArithmeticalValue(var_id);
                              }

                              RESULT = sym;

                            :}
                            | POS_NEG:neg number:n_val
                            {:
                              Integer value;

                              if(neg.isNegative()){
                                value = new Integer("-" + n_val);
                              }
                              else{
                                value = new Integer(n_val);
                              }

                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND

                              RESULT = new SymbolArithmeticalValue(var_id, value);
                            :}
                            | id:id_val
                            {:

                              Type var_type = symbolsTable.get(id_val);
                              TYPE main_var_type = var_type.getType();

                              if(main_var_type != TYPE.darg && main_var_type != TYPE.dconst && main_var_type != TYPE.dvar){
                                throw new Error("Invalid arithmetic value type")
                              }

                              Type var_dtype = symbolsTable.get(var_type.getTypeName());

                              if(var_dtype.getSubType() != SUBJACENTTYPE.st_integer){
                                throw new Error("Invalid subjacent type")
                              }

                              SymbolArithValue sym;
                              String var_id = new String(var_type.getBackendId());

                              if(main_var_type == TYPE.dconst){
                                Integer value = (Integer) var_type.getValue();¡
                                sym = new SymbolArithmeticalValue(var_id, value);
                              }else{
                                sym = new SymbolArithmeticalValue(var_id);
                              }

                              RESULT = sym;
                            
                            :} ;


POS_NEG                     ::= op_arithmetical:op
                            {:

                              if(!op.equals("+") && !op.equals("-")){
                                throw new Error("Sign operator not valid")
                              }

                              boolean isNegative = true;
                              
                              if(op.equals("+")){
                                isNegative = false;
                              }

                              RESULT = new SymbolPosNeg(isNegative);
                            :}
                            | 
                            {:
                              RESULT = new SymbolPosNeg(false);
                            :};


VALUE                       ::= INITIALIZE_ARITHMETICAL_OP:arith_op
                            {:
                              SymbolValue sym;
                              String var_id = new String(arith_op.getVarId());
                              if(arith_op.getIsConst()){
                                sym = new SymbolValue(var_id, SUBJACENTTYPE.st_integer, arith_op.getValue())
                              }else{
                                sym = new SymbolValue(var_id, SUBJACENTTYPE.st_integer);
                              }

                              RESULT = sym;
                            :}
                            | POS_NEG:neg number:n_val
                            {:
                              Integer value;

                              if(neg.isNegative()){
                                value = new Integer("-" + n_val);
                              }
                              else{
                                value = new Integer(n_val);
                              }

                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND

                              RESULT = new SymbolValue(var_id, SUBJACENTTYPE.st_integer, value);
                            :}
                            | string:str_val 
                            {:
                              String value = new String(str_val.replace("\"", "")); //delete quotes

                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND
                              RESULT = new SymbolValue(var_id, SUBJACENTTYPE.st_string, value);
                            :}
                            | bool:bool_val
                            {:
                              Boolean value = new Boolean(bool_val);
                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND
                              RESULT = new SymbolValue(var_id, SUBJACENTTYPE.st_boolean, value);
                            :}
                            | id:id_val
                            {:
                              SymbolValue sym;
                              
                              Type val_type = symbolsTable.get(id_val);
                              String var_id = new String(val_type.getBackendId());

                              if(val_type.getType() == TYPE.dconst){
                                sym = new SymbolValue(var_id, val_type.getType(), val_type.getTypeName(), val_type.getValue());
                              }
                              else {
                                sym = new SymbolValue(var_id, val_type.getType(), val_type.getTypeName());
                              }

                              RESULT = sym;
                            :}
                            | INITIALIZE_BOOLEAN_OP:bool_op
                            {:
                              SymbolValue sym;
                              String var_id = new String(bool_op.getVarId());
                              if(bool_op.getIsConst()){
                                sym = new SymbolValue(var_id, SUBJACENTTYPE.st_boolean, bool_op.getValue())
                              }else{
                                sym = new SymbolValue(var_id, SUBJACENTTYPE.st_boolean);
                              }

                              RESULT = sym;
                            :}
                            | CALL_FUNCTION:call_fn
                            {:
                              Type fn_type = symbolsTable.get(call_fn);
                              Type dfn_type = symbolsTable.get(fn_type.getTypeName());

                              //FER COSES BACKEND
                                String var_id = "ABC"
                              //FER COSES BACKEND

                              RESULT = new SymbolValue(var_id, TYPE.dfun, fn_type.getTypeName());
                            :}
                            | instr_in lparen id rparen;

INITIALIZE_BOOLEAN_OP       ::= lparen BOOLEAN_OP rparen ;

BOOLEAN_OP                  ::= BOOLEAN_OP op_logical BOOLEAN_VALUE
                            | BOOLEAN_VALUE ;

BOOLEAN_VALUE               ::= bool
                            | id
                            | lparen BOOLEAN_OP rparen
                            | VALUE_COMPARISON ;

VALUE_COMPARISON            ::= lparen VALUE op_relational VALUE rparen ;



INSTRUCTION_IF               ::= inst_if lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES; // if(( x < y)){}

OTHER_CASES                  ::= inst_else lbracket INSTRUCTIONS rbracket  // else{}
                             | inst_elif lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES // elif ((x > y)){}
                             | ;

 
INSTRUCTION_WHILE            ::= inst_while lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket;         // while(( x < 10)){}


INSTRUCTION_FOR              ::= inst_for lparen INTERNAL_FOR rparen lbracket INSTRUCTIONS rbracket;
INTERNAL_FOR                 ::= OPERATOR_ASSIG nextinstr INITIALIZE_BOOLEAN_OP nextinstr ARITHMETICAL_OP 
                             | ;


INSTRUCTION_SWITCH           ::= inst_switch lparen VALUE rparen lbracket CASES rbracket ;
CASES                        ::= inst_case VALUE two_points INSTRUCTIONS inst_break nextinstr CASES
                             | CASE_DEFAULT;
CASE_DEFAULT                 ::= inst_default INSTRUCTIONS inst_break nextinstr
                             | ;


CALL_FUNCTION               ::= inst_call lparen CALL_BODY rparen nextinstr;

CALL_BODY                   ::= CALL_BODY separator VALUE
                            | id;


INSTRUCTION_OUT             ::= instr_out lparen VALUE rparen nextinstr;


DEFINE_FUNCTION             ::= FUNCTION_BEG id  rparen lbracket FUNCTION_BODY RETURN_TYPE  rbracket;

FUNCTION_BEG                ::= inst_function id id lparen PARAMETERS rparen;

PARAMETERS                  ::= HAS_PARAMETERS
                            | ;

HAS_PARAMETERS              ::=  id id HAS_MORE_PARAMETERS ;

HAS_MORE_PARAMETERS         ::= separator id id HAS_MORE_PARAMETERS
                            | ;

FUNCTION_BODY               ::= INSTRUCTIONS
                            | ;

RETURN_TYPE                 ::= inst_return VALUE nextinstr
                            | ;

package compilador;


import java_cup.runtime.Symbol;
import Symbols.*;
import SymbolsTable.*;

parser code
{:
  private SymbolsTable symbolsTable;
:};

/******Declaració de simbols terminals*********/
terminal        character, id, number, string, bool, Void, op_relational, op_logical, op_arithmetical, op_assig, inst_if, inst_elif, inst_else,
                inst_switch, inst_case, inst_break, inst_default, inst_while, inst_for, inst_function, inst_return, dconst, inst_call, 
                instr_in, instr_out,  lparen, rparen, lbracket, rbracket, nextinstr, separator, two_points, inst_main,id_main,
                spc_asgmul, spc_asgdec, spc_dec,spc_asgdiv,spc_asginc,spc_inc ;


/******Declaració de simbols no terminals*********/

non terminal  SymbolStarts                STARTS;
non terminal  SymbolInit                  INIT;
non terminal  SymbolCallMain              CALL_MAIN;
non terminal  SymbolInstructions          INSTRUCTIONS;
non terminal  SymbolInstruction           INSTRUCTION;
non terminal  SymbolDeclarations          DECLARATIONS;
non terminal  SymbolOperatorAssignation   OPERATOR_ASSIG;
non terminal  SymbolInstructionIn         INSTRUCTION_IN;
non terminal  SymbolInstructionOut        INSTRUCTION_OUT;
non terminal  SymbolConstant              CONSTANT;
non terminal  SymbolValue                 VALUE;
non terminal  SymbolInitArithOp           INITIALIZE_ARITHMETICAL_OP;
non terminal  SymbolArithmeticalOperator  ARITHMETICAL_OP;
non terminal  SymbolArithValue            ARITHMETICAL_VALUE;
non terminal  SymbolPosNeg                POS_NEG;
non terminal  SymbolBoolOp                BOOLEAN_OP;
non terminal  SymbolInitBoolOp            INITIALIZE_BOOLEAN_OP;
non terminal  SymbolBoolValue             BOOLEAN_VALUE;
non terminal  SymbolValueComparison       VALUE_COMPARISON;
non terminal  SymbolInstructionIf         INSTRUCTION_IF;
non terminal  SymbolOtherCases            OTHER_CASES;
non terminal  SymbolInstructionWhile      INSTRUCTION_WHILE;
non terminal  SymbolInstructionFor        INSTRUCTION_FOR;
non terminal  SymbolInternalFor           INTERNAL_FOR;
non terminal  SymbolInstructionSwitch     INSTRUCTION_SWITCH;
non terminal  SymbolCases                 CASES;
non terminal  SymbolCaseDefault           CASE_DEFAULT;
non terminal  SymbolDefFunction           DEFINE_FUNCTION;
non terminal  SymbolCallFunction          CALL_FUNCTION;
non terminal  SymbolCallBody              CALL_BODY;
non terminal  SymbolFunctionBeg           FUNCTION_BEG;
non terminal  SymbolParameters            PARAMETERS;
non terminal  SymbolHasParameters         HAS_PARAMETERS;
non terminal  SymbolHasMoreParameters     HAS_MORE_PARAMETERS;
non terminal  SymbolFunctionBody          FNCTION_BODY;
non terminal  SymbolReturnType            RETURN_TYPE;

start with STARTS;

STARTS                      ::=  INIT DEFINE_FUNCTION CALL_MAIN ;

INIT                        ::= ;

DEFINE_FUNCTION             ::= lparen; // TOCARÁ CAMBIARSE EN UN FUTURO SEMANTICO

CALL_MAIN                   ::= inst_main lparen id_main rparen nextinstr;

INSTRUCTIONS                ::=   INSTRUCTIONS INSTRUCTION
                            | INSTRUCTION ;

INSTRUCTION                 ::=  DECLARATIONS
                            | INSTRUCTION_IF
                            | INSTRUCTION_WHILE
                            | INSTRUCTION_SWITCH
                            | INSTRUCTION_FOR
                            | OPERATOR_ASSIG
                            | INSTRUCTION_IN
                            | INSTRUCTION_OUT 
                            | DEFINE_FUNCTION;



DECLARATIONS                ::=  id separator DECLARATIONS
                            | id CONSTANT two_points id op_assig VALUE nextinstr 
                            | spc_asgmul
                            | spc_asgdec    
                            | spc_dec
                            | spc_asgdiv
                            | spc_asginc
                            | spc_inc;


CONSTANT                    ::=  dconst
                            |  ;


OPERATOR_ASSIG              ::= id op_assig VALUE nextinstr;    


INITIALIZE_ARITHMETICAL_OP  ::= lparen ARITHMETICAL_OP rparen ;


ARITHMETICAL_OP             ::= ARITHMETICAL_OP op_arithmetical ARITHMETICAL_VALUE
                            | ARITHMETICAL_VALUE op_arithmetical ARITHMETICAL_VALUE ;

 
ARITHMETICAL_VALUE          ::= lparen ARITHMETICAL_OP rparen
                            | POS_NEG number
                            | id ;


POS_NEG                     ::= op_arithmetical    /*  + 25  */
                            |  ;


VALUE                       ::= INITIALIZE_ARITHMETICAL_OP
                            | POS_NEG number
                            | character
                            | string
                            | bool
                            | id
                            | INITIALIZE_BOOLEAN_OP
                            | CALL_FUNCTION
                            | Void
                            | instr_in lparen id rparen;

INITIALIZE_BOOLEAN_OP       ::= lparen BOOLEAN_OP rparen ;

BOOLEAN_OP                  ::= BOOLEAN_OP op_logical BOOLEAN_VALUE
                            | BOOLEAN_VALUE ;

BOOLEAN_VALUE               ::= bool
                            | id
                            | lparen BOOLEAN_OP rparen
                            | VALUE_COMPARISON ;

VALUE_COMPARISON            ::= lparen VALUE op_relational VALUE rparen ;



INSTRUCTION_IF               ::= inst_if lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES; // if(( x < y)){}

OTHER_CASES                  ::= inst_else lbracket INSTRUCTIONS rbracket  // else{}
                             | inst_elif lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket OTHER_CASES // elif ((x > y)){}
                             | ;

 
INSTRUCTION_WHILE            ::= inst_while lparen INITIALIZE_BOOLEAN_OP rparen lbracket INSTRUCTIONS rbracket;         // while(( x < 10)){}


INSTRUCTION_FOR              ::= inst_for lparen INTERNAL_FOR rparen lbracket INSTRUCTIONS rbracket;
INTERNAL_FOR                 ::= OPERATOR_ASSIG nextinstr INITIALIZE_BOOLEAN_OP nextinstr ARITHMETICAL_OP 
                             | ;


INSTRUCTION_SWITCH           ::= inst_switch lparen VALUE rparen lbracket CASES rbracket ;
CASES                        ::= inst_case VALUE two_points INSTRUCTIONS inst_break nextinstr CASES
                             | CASE_DEFAULT;
CASE_DEFAULT                 ::= inst_default INSTRUCTIONS inst_break nextinstr
                             | ;


CALL_FUNCTION               ::= inst_call lparen CALL_BODY rparen nextinstr;

CALL_BODY                   ::= CALL_BODY separator VALUE
                            | id;


INSTRUCTION_OUT             ::= instr_out lparen VALUE rparen nextinstr;


DEFINE_FUNCTION             ::= FUNCTION_BEG id  rparen lbracket FUNCTION_BODY RETURN_TYPE  rbracket;

FUNCTION_BEG                ::= inst_function id id lparen PARAMETERS rparen;

PARAMETERS                  ::= HAS_PARAMETERS
                            | ;

HAS_PARAMETERS              ::=  id id HAS_MORE_PARAMETERS ;

HAS_MORE_PARAMETERS         ::= separator id id HAS_MORE_PARAMETERS
                            | ;

FUNCTION_BODY               ::= INSTRUCTIONS
                            | ;

RETURN_TYPE                 ::= inst_return VALUE nextinstr
                            | ;
